---
# Custom intervals:
# fixed: 0;1h/1-7,00:00-24:00
# scheduling: 0;m0-59
templates:
  - name: Template OS Windows CPU by Zabbix agent
    _zbx_ver: "3.4"
    _classes:
      - OS
    items:
      # WMI counters
      # - _id: w
      #   _group: "CPU"
      #   name: Interrupt Time, %
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2,SELECT PercentInterruptTime FROM Win32_PerfFormattedData_PerfOS_Processor where Name='_Total']
      #   value_type: FLOAT
      #   units: "%"
      #   delay: 0;m0-59
      # - _id: w
      #   _group: "CPU"
      #   name: Load, %
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2,select PercentProcessorTime from Win32_PerfformattedData_PerfOS_Processor where Name='_Total']
      #   value_type: FLOAT
      #   units: "%"
      #   delay: 0;m0-59
      # - _id: w
      #   _group: "CPU"
      #   name: Privileged time, %
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2, SELECT PercentPrivilegedTime FROM Win32_PerfFormattedData_PerfOS_Processor where Name='_Total']
      #   value_type: FLOAT
      #   units: "%"
      #   delay: 0;m0-59
      # - _id: w
      #   _group: "CPU"
      #   name: User time, %
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2,SELECT PercentUserTime FROM Win32_PerfFormattedData_PerfOS_Processor where Name='_Total']
      #   value_type: FLOAT
      #   units: "%"
      #   delay: 0;m0-59
      # - _id: w
      #   _group: "CPU"
      #   name: Queue Length
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2, SELECT ProcessorQueueLength FROM Win32_PerfFormattedData_PerfOS_System]
      #   value_type: FLOAT
      #   delay: 0;m0-59
      # Performance counters
      - _id: system.cpu.interrupt.time
        _group: "CPU"
        name: Interrupt Time, %
        type: ZABBIX_PASSIVE
        key: perf_counter_en["\Processor Information(_total)\% Interrupt Time"]
        value_type: FLOAT
        units: "%"
        delay: 0;m0-59
        description: |
          The Processor Information\% Interrupt Time is the time the processor spends receiving and servicing 
          hardware interrupts during sample intervals. This value is an indirect indicator of the activity of 
          devices that generate interrupts, such as the system clock, the mouse, disk drivers, data communication 
          lines, network interface cards and other peripheral devices. This is an easy way to identify a potential 
          hardware failure. This should never be higher than 20%.
        triggers:
          - _id: t
            name: "CPU Interrupt Time is high (over {$CPU.INTERRUPT.WARN.MAX}% for 5m)"
            priority: "AVERAGE"
            expression: "{TEMPLATE_NAME:METRIC.min(5m)}>{$CPU.INTERRUPT.WARN.MAX}"
            description: "The CPU Interrupt Time in the last 5 minutes exceeds {$CPU.INTERRUPT.WARN.MAX}%."
            _depends_on:
              - trigger.cpu.high
              - trigger.cpu.interrupt.high
          - _id: trigger.cpu.interrupt.high
            name: "CPU Interrupt Time is too high (over {$CPU.INTERRUPT.CRIT.MAX}% for 5m)"
            priority: "HIGH"
            expression: "{TEMPLATE_NAME:METRIC.min(5m)}>{$CPU.INTERRUPT.CRIT.MAX}"
            description: "The CPU Interrupt Time in the last 5 minutes exceeds {$CPU.INTERRUPT.CRIT.MAX}%."
            _depends_on:
              - trigger.cpu.high
      # - _id: p
      #   _group: "CPU"
      #   name: Load, %
      #   type: ZABBIX_PASSIVE
      #   key: perf_counter_en["\Processor Information(_total)\% Processor Time"]
      #   value_type: FLOAT
      #   units: "%"
      #   delay: 0;m0-59
      #   description: |
      #     The Processor Information\% Processor Time shows how much the processor(s) is being utilized.
      - _id: system.cpu.priv.time
        _group: "CPU"
        name: Privileged time, %
        type: ZABBIX_PASSIVE
        key: perf_counter_en["\Processor Information(_total)\% Privileged Time"]
        value_type: FLOAT
        units: "%"
        delay: 0;m0-59
        description: |
          The Processor Information\% Privileged Time counter shows the percent of time that the processor is spent 
          executing in Kernel (or Privileged) mode. Privileged mode includes services interrupts inside Interrupt 
          Service Routines (ISRs), executing Deferred Procedure Calls (DPCs), Device Driver calls and other kernel-mode 
          functions of the Windows® Operating System.
        triggers:
          - _id: trigger.cpu.priv.high
            name: "CPU Privileged Time is too high (over {$CPU.PRIV.CRIT.MAX}% for 5m)"
            priority: "HIGH"
            expression: "{TEMPLATE_NAME:METRIC.min(5m)}>{$CPU.PRIV.CRIT.MAX}"
            description: "The CPU Privileged Time in the last 5 minutes exceeds {$CPU.PRIV.CRIT.MAX}%."
            _depends_on:
              - trigger.cpu.high
      - _id: system.cpu.user.time
        _group: "CPU"
        name: User time, %
        type: ZABBIX_PASSIVE
        key: perf_counter_en["\Processor Information(_total)\% User Time"]
        value_type: FLOAT
        units: "%"
        delay: 0;m0-59
        description: |
          The Processor Information\% User Time counter shows the percent of time that the processor(s) is spent executing 
          in User mode.
        graphs:
          - name: CPU % Time
            graph_items:
              - name: system.cpu.interrupt.time
                drawtype: SINGLE_LINE
              - name: system.cpu.user.time
                drawtype: SINGLE_LINE
              - name: system.cpu.priv.time
                drawtype: SINGLE_LINE
              - name: system.cpu.queue.length
                drawtype: SINGLE_LINE
                yaxisside: RIGHT
              - name: system.cpu.util
                drawtype: SINGLE_LINE
      - _id: system.cpu.queue.length
        _group: "CPU"
        name: Queue Length
        type: ZABBIX_PASSIVE
        key: perf_counter_en["\System\Processor Queue Length"]
        value_type: FLOAT
        delay: 0;m0-59
        description: |
          The Processor Queue Length shows the number of threads that are observed as delayed in the processor Ready Queue 
          and are waiting to be executed.
        triggers:
          - _id: trigger.cpu.queue.length
            name: "CPU Queue Length is too high (over {$CPU.QUEUE.CRIT.MAX}% for 5m)"
            priority: "HIGH"
            expression: "{TEMPLATE_NAME:METRIC.min(5m)}>{$CPU.QUEUE.CRIT.MAX}"
            description: "The CPU Queue Length in the last 5 minutes exceeds {$CPU.QUEUE.CRIT.MAX}%."
            _depends_on:
              - trigger.cpu.high
      #       - _id: system.cpu.util.avg
      #         _group: "CPU"
      #         name: CPU utilisation, in %
      #         type: CALCULATED
      #         params: "( last(system.cpu.util[0]) +
      # last(system.cpu.util[1]) +
      # last(system.cpu.util[2]) +
      # last(system.cpu.util[3]) +
      # last(system.cpu.util[4]) +
      # last(system.cpu.util[5]) +
      # last(system.cpu.util[6]) +
      # last(system.cpu.util[7]) ) / 8"
      #         key: system.cpu.util.avg
      #         value_type: FLOAT
      #         units: "%"
      #         delay: 0;m0-59s5
      - _prototype: system.cpu.util
        type: ZABBIX_PASSIVE
        key: system.cpu.util
        delay: 0;m0-59
        triggers:
          - _prototype: trigger.cpu.high
            # name: "CPU utilization is too high (over {$CPU_UTIL_MAX}% for 10m)"
            # expression: "{TEMPLATE_NAME:METRIC.avg(10m)}>{$CPU_UTIL_MAX}"
            # description: "The average CPU usage in the last 10 minutes exceeds {$CPU_UTIL_MAX}%."
          # - _id: trigger.cpu.util.warn
          #   name: "CPU utilization is too high (over {$CPU_UTIL_MAX}% for 10m)"
          #   priority: "AVERAGE"
          #   expression: "{TEMPLATE_NAME:METRIC.avg(10m)}>{$CPU_UTIL_MAX}"
          #   description: "The average CPU usage in the last 10 minutes exceeds {$CPU_UTIL_MAX}%."

    # discovery_rules:
    #   - name: CPU core discovery
    #     key: system.cpu.discovery
    #     type: ZABBIX_PASSIVE
    #     description: Discovery of CPU cores as defined in macros {$CPU.NUMBER.MATCHES},{$CPU.NUMBER.NOT_MATCHES},{$CPU.STATUS.MATCHES},{$CPU.STATUS.NOT_MATCHES}.
    #     delay: 1d
    #     items:
    #       - _prototype: system.cpu.util
    #         _group: "CPU"
    #         _resource: "#{#CPU.NUMBER}"
    #         type: ZABBIX_PASSIVE
    #         key: system.cpu.util[{#CPU.NUMBER}]
    #         delay: 0;m0-59
    #         description: "CPU core #{#CPU.NUMBER} utilization in %"
    #         # triggers:
    #         #   - _id: trigger.cpu.util.warn
    #         #     name: 'CPU core #{#CPU.NUMBER} utilization is too high (over {$CPU_UTIL_MAX:"#{#CPU.NUMBER}"}% for 5m)'
    #         #     priority: "WARNING"
    #         #     expression: '{TEMPLATE_NAME:METRIC.avg(5m)}>{$CPU_UTIL_MAX:"#{#CPU.NUMBER}"}'
    #         #     description: 'The average CPU core #{#CPU.NUMBER} usage in the last 5 minutes exceeds {$CPU_UTIL_MAX:"#{#CPU.NUMBER}"}%.'
    #         #     _depends_on:
    #         #       - trigger.cpu.high
    #     filter:
    #       evaltype: AND
    #       conditions:
    #         - macro: "{#CPU.NUMBER}"
    #           value: "{$CPU.NUMBER.MATCHES}"
    #           formulaid: A
    #           operator: MATCHES_REGEX
    #         - macro: "{#CPU.NUMBER}"
    #           value: "{$CPU.NUMBER.NOT_MATCHES}"
    #           formulaid: B
    #           operator: NOT_MATCHES_REGEX
    #         - macro: "{#CPU.STATUS}"
    #           value: "{$CPU.STATUS.MATCHES}"
    #           formulaid: C
    #           operator: MATCHES_REGEX
    #         - macro: "{#CPU.STATUS}"
    #           value: "{$CPU.STATUS.NOT_MATCHES}"
    #           formulaid: D
    #           operator: NOT_MATCHES_REGEX
    macros:
      - macro: "{$CPU.INTERRUPT.WARN.MAX}"
        _description: The warning threshold of the % Interrupt Time counter.
        value: "30"
      - macro: "{$CPU.INTERRUPT.CRIT.MAX}"
        _description: The critical threshold of the % Interrupt Time counter.
        value: "50"
      - macro: "{$CPU.PRIV.CRIT.MAX}"
        _description: The threshold of the % Privileged Time counter.
        value: "20"
      - macro: "{$CPU.QUEUE.CRIT.MAX}"
        _description: The threshold of the Processor Queue Length counter.
        value: "3"
    #   - macro: "{$CPU.NUMBER.MATCHES}"
    #     _description: CPU index or number of CPU/CPU core.
    #     value: ^.+$
    #   - macro: "{$CPU.NUMBER.NOT_MATCHES}"
    #     _description: CPU index or number of CPU/CPU core.
    #     value: ^\s$
    #   - macro: "{$CPU.STATUS.MATCHES}"
    #     _description: Whether the cpu is online/offline.
    #     value: ^online$
    #   - macro: "{$CPU.STATUS.NOT_MATCHES}"
    #     _description: Whether the cpu is online/offline.
    #     value: ^\s$
  - name: Template OS Windows filesystems by Zabbix agent
    _zbx_ver: "3.4"
    _classes:
      - OS
    macros:
      - macro: "{$VFS.FS.FSNAME.MATCHES}"
        value: ".*"
        _description: "This macro is used in filesystems discovery. Can be overriden on the host or linked template level."
      - macro: "{$VFS.FS.FSNAME.NOT_MATCHES}"
        value: "^(/dev|/sys|/run|/proc|.+/shm$)"
        _description: "This macro is used in filesystems discovery. Can be overriden on the host or linked template level."
      - macro: "{$VFS.FS.FSTYPE.MATCHES}"
        value: ".*"
        _description: "This macro is used in filesystems discovery. Can be overriden on the host or linked template level."
      - macro: "{$VFS.FS.FSTYPE.NOT_MATCHES}"
        value: "^\\s$"
        _description: "This macro is used in filesystems discovery. Can be overriden on the host or linked template level."
      - macro: "{$VFS.FS.FSDRIVETYPE.MATCHES}"
        value: "fixed"
        _description: "This macro is used in filesystems discovery. Can be overriden on the host or linked template level."
      - macro: "{$VFS.FS.FSDRIVETYPE.NOT_MATCHES}"
        value: "^\\s$"
        _description: "This macro is used in filesystems discovery. Can be overriden on the host or linked template level."
    discovery_rules:
      - name: "Mounted filesystem discovery"
        key: "vfs.fs.discovery"
        type: "ZABBIX_PASSIVE"
        description: "Discovery of file systems of different types."
        filter:
          evalType: "AND"
          conditions:
            - macro: "{#FSTYPE}"
              value: "{$VFS.FS.FSTYPE.MATCHES}"
              operator: "MATCHES_REGEX"
              formulaid: "A"
            - macro: "{#FSTYPE}"
              value: "{$VFS.FS.FSTYPE.NOT_MATCHES}"
              operator: "NOT_MATCHES_REGEX"
              formulaid: "B"
            - macro: "{#FSNAME}"
              value: "{$VFS.FS.FSNAME.MATCHES}"
              operator: "MATCHES_REGEX"
              formulaid: "C"
            - macro: "{#FSNAME}"
              value: "{$VFS.FS.FSNAME.NOT_MATCHES}"
              operator: "NOT_MATCHES_REGEX"
              formulaid: "D"
            - macro: "{#FSDRIVETYPE}"
              value: "{$VFS.FS.FSDRIVETYPE.MATCHES}"
              operator: MATCHES_REGEX
              formulaid: E
            - macro: "{#FSDRIVETYPE}"
              value: "{$VFS.FS.FSDRIVETYPE.NOT_MATCHES}"
              operator: NOT_MATCHES_REGEX
              formulaid: F
        items:
          - _prototype: "vfs.fs.used"
            type: "ZABBIX_PASSIVE"
            key: "vfs.fs.size[{#FSNAME},used]"
            _group: "Filesystems"
            _resource: "{#FSNAME}"
            application_prototype: "Filesystem __RESOURCE__"
          - _prototype: "vfs.fs.total"
            type: "ZABBIX_PASSIVE"
            key: "vfs.fs.size[{#FSNAME},total]"
            _group: "Filesystems"
            _resource: "{#FSNAME}"
            application_prototype: "Filesystem __RESOURCE__"
          - _prototype: "vfs.fs.pused"
            type: "ZABBIX_PASSIVE"
            key: "vfs.fs.size[{#FSNAME},pused]"
            _group: "Filesystems"
            _resource: "{#FSNAME}"
            application_prototype: "Filesystem __RESOURCE__"

  # - name: Template OS Windows disk performance by Zabbix agent
  #   _zbx_ver: "3.4"
  #   _classes:
  #     - OS

  - name: Template OS Windows inventory by Zabbix agent
    _zbx_ver: "3.4"
    _classes:
      - OS
    items:
      - _prototype: "system.uptime"
        _group: "General"
        type: "ZABBIX_PASSIVE"
        key: "system.uptime"
        name: "System uptime"
        triggers:
          - _prototype: "trigger.uptime.restarted"
            priority: "WARNING"
            name: "Host has been restarted (uptime < 10m)"
            description: "The device uptime is less than 10 minutes."
      - _id: system.uname
        _group: "General"
        name: System information
        type: ZABBIX_PASSIVE
        key: system.uname
        value_type: CHAR
        delay: 1h
      - _id: proc.num[]
        _group: "General"
        name: Number of processes
        type: ZABBIX_PASSIVE
        key: proc.num[]
        value_type: UNSIGNED
      - _id: sys.threads
        _group: "General"
        name: Number of threads
        type: ZABBIX_PASSIVE
        key: perf_counter_en["\System\Threads"]
        value_type: UNSIGNED
        description: "The number of threads used by all running processes."
      # - _id: system.uptime
      #   _group: "General"
      #   name: System uptime
      #   type: ZABBIX_PASSIVE
      #   key: system.uptime
      #   value_type: UNSIGNED
      #   delay: 1m
      #   units: uptime
      #   triggers:
      #     - _prototype: trigger.uptime.restarted
      #       priority: WARNING
      #       name: Host has been restarted (uptime < 10m)
      #       description: The device uptime is less than 10 minutes.
      # _depends_on:
      # - _id: custom.os.updates.latestupdatesinstalled
      #   _group: "General"
      #   name: Latest update installed days ago
      #   type: ZABBIX_PASSIVE
      #   key: custom.os.updates.latestupdatesinstalled
      #   value_type: UNSIGNED
      #   delay: 1d
      #   units: s
      # - _id: custom.os.pendingreboot
      #   _group: "General"
      #   name: Pending reboot
      #   type: ZABBIX_PASSIVE
      #   key: custom.os.pendingreboot
      #   value_type: UNSIGNED
      #   delay: 1d

  - name: Template OS Windows memory by Zabbix agent
    _zbx_ver: "3.4"
    _classes:
      - OS
    macros:
      - macro: "{$MEM.COMMITED.CRIT.MAX}"
        _description: "The warning threshold of the % Committed Bytes In Use counter."
        value: "80"
      - macro: "{$MEM.PAGE_TABLE.CRIT.MAX}"
        _description: "The warning threshold of the Free System Page Table Entries counter."
        value: "5000"
      - macro: "{$MEM.PAGE_SEC.CRIT.MAX}"
        _description: "The warning threshold of the Memory Pages/sec counter."
        value: "1000"
    items:
      - _prototype: "vm.memory.used"
        key: "vm.memory.size[used]"
        type: "ZABBIX_PASSIVE"
      - _prototype: "vm.memory.pused"
        key: "vm.memory.size[pused]"
        type: "ZABBIX_PASSIVE"
      - _prototype: "vm.memory.total"
        key: "vm.memory.size[total]"
        type: "ZABBIX_PASSIVE"
      # - _prototype: "vm.memory.available"
      #   key: "vm.memory.size[available]"
      #   type: "ZABBIX_PASSIVE"
      - _prototype: "system.swap.free"
        key: "system.swap.size[,free]"
        type: "ZABBIX_PASSIVE"
      - _prototype: "system.swap.pfree"
        key: "system.swap.size[,pfree]"
        type: "ZABBIX_PASSIVE"
      - _prototype: "system.swap.total"
        key: "system.swap.size[,total]"
        type: "ZABBIX_PASSIVE"
      # WMI counters
      # - _id: M
      #   _group: "Memory"
      #   _resource: "Memory"
      #   name: Available
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2,SELECT AvailableBytes FROM Win32_PerfFormattedData_PerfOS_Memory]
      #   value_type: UNSIGNED
      #   delay: 1m
      #   units: B
      #   description: |
      #     Performance counter measures the amount of physical memory (RAM), in megabytes, that is immediately
      #     available for allocation either to a process or for system use. It is the sum of the Zero, Free,
      #     and Standby page lists discussed earlier. When the Available MBytes counter is low, it is a primary
      #     indicator of a low RAM condition. This is when aggressive working set trims will occur which may or
      #     may not result in a hard page fault where the pages on the Modified list are written to disk.
      #     The \Memory\Pages/sec counter measures hard page faults, but it does not distinguish between hard
      #     page faults that result from normal file reads or writes and page file reads or writes. Therefore,
      #     use Pages/sec together with the Available MBytes counter, and do not use Pages/sec by itself.
      # - _id: M
      #   _group: "Memory"
      #   _resource: "Memory"
      #   name: Cache bytes
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2,SELECT CacheBytes FROM Win32_PerfFormattedData_PerfOS_Memory]
      #   value_type: UNSIGNED
      #   delay: 1m
      #   units: B
      #   description: |
      #     \Memory\Cache Bytes
      #     Cache Bytes is the sum of the Memory\\System Cache Resident Bytes, Memory\\System Driver Resident Bytes,
      #     Memory\\System Code Resident Bytes, and Memory\\Pool Paged Resident Bytes counters. This counter displays
      #     the last observed value only; it is not an average.
      #     The Memory performance object consists of counters that describe the behavior of physical and virtual
      #     memory on the computer. Physical memory is the amount of random access memory on the computer. Virtual
      #     memory consists of the space in physical memory and on disk. Many of the memory counters monitor paging,
      #     which is the movement of pages of code and data between disk and physical memory. Excessive paging,
      #     a symptom of a memory shortage, can cause delays which interfere with all system processes.
      # - _id: M
      #   _group: "Memory"
      #   _resource: "Memory"
      #   name: Commit limit
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2,SELECT CommitLimit FROM Win32_PerfFormattedData_PerfOS_Memory]
      #   value_type: UNSIGNED
      #   delay: 1m
      #   units: B
      #   description: |
      #     Commit Limit is the amount of virtual memory that can be committed without having to extend
      #     the paging file(s). It is measured in bytes. Committed memory is the physical memory which
      #     has space reserved on the disk paging files. There can be one paging file on each logical drive).
      #     If the paging file(s) are be expanded, this limit increases accordingly. This counter displays
      #     the last observed value only; it is not an average.
      # - _id: M
      #   _group: "Memory"
      #   _resource: "Memory"
      #   name: Committed
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2,SELECT CommittedBytes FROM Win32_PerfFormattedData_PerfOS_Memory]
      #   value_type: UNSIGNED
      #   delay: 1m
      #   units: B
      #   description: |
      #     \Memory\Committed Bytes
      #     The system commit charge is the total amount of committed memory that is in use by all processes
      #     and by the kernel. This memory might have been guaranteed or written to by a process or by the kernel.
      #     Memory Available Megabytes in Use This measures the ratio of Committed Bytes to the Commit Limit—in other
      #     words, the amount of virtual memory in use. This indicates insufficient memory if the number is greater
      #     than 80 percent. The obvious solution for this is to add more memory.
      # - _id: M
      #   _group: "Memory"
      #   _resource: "Memory"
      #   name: Committed in use, %
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2,SELECT PercentCommittedBytesInUse FROM Win32_PerfFormattedData_PerfOS_Memory]
      #   value_type: FLOAT
      #   delay: 1m
      #   units: "%"
      #   description: |
      #     The \Memory\% Committed Bytes In Use counter calculates the ratio of committed bytes (system commit charge)
      #     to the system commit limit, and the system can perform poorly when the system commit limit is reached.
      #     Therefore, when % Committed Bytes In Use is greater than 80%, use the \Process(*)\Private Bytes counter
      #     to identify the processes that are consuming the most committed memory.
      #     The Debug Diagnostic Tool (DebugDiag) is designed to assist in troubleshooting issues such as hangs,
      #     slow performance, memory leaks or fragmentation, and crashes in any user-mode process. The tool includes
      #     additional debugging scripts focused on Internet Information Services (IIS) applications, web data access
      #     components, COM+ and related Microsoft technologies.
      # - _id: M
      #   _group: "Memory"
      #   _resource: "Memory"
      #   name: Free system page table entries
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2,SELECT FreeSystemPageTableEntries FROM Win32_PerfFormattedData_PerfOS_Memory]
      #   value_type: UNSIGNED
      #   delay: 1m
      #   description: |
      #     This indicates the number of page table entries not currently in use by the system. If the number is less
      #     than 5,000, there may well be a memory leak.
      # - _id: M
      #   _group: "Memory"
      #   _resource: "Memory"
      #   name: Page file usage, %
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2, SELECT PercentUsagePeak FROM Win32_PerfFormattedData_PerfOS_PagingFile]
      #   value_type: FLOAT
      #   delay: 1m
      #   units: "%"
      #   description: |
      #     The peak usage of the Page File instance in percent.
      #     The Paging File performance object consists of counters that monitor the paging file(s) on the computer.
      #     The paging file is a reserved space on disk that backs up committed physical memory on the computer.
      # - _id: M
      #   _group: "Memory"
      #   _resource: "Memory"
      #   name: Pages faults per/sec
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2,SELECT PageFaultsPersec FROM Win32_PerfFormattedData_PerfOS_Memory]
      #   value_type: FLOAT
      #   delay: 1m
      #   description: |
      #     Page Faults/sec is the average number of pages faulted per second. It is measured in number of pages
      #     faulted per second because only one page is faulted in each fault operation, hence this is also equal
      #     to the number of page fault operations. This counter includes both hard faults (those that require
      #     disk access) and soft faults (where the faulted page is found elsewhere in physical memory.) Most
      #     processors can handle large numbers of soft faults without significant consequence. However, hard faults,
      #     which require disk access, can cause significant delays.
      # - _id: M
      #   _group: "Memory"
      #   _resource: "Memory"
      #   name: Pages per/sec
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2, select PagesPersec FROM Win32_PerfFormattedData_PerfOS_Memory]
      #   value_type: FLOAT
      #   delay: 1m
      #   description: |
      #     This measures the rate at which pages are read from or written to disk to resolve hard page faults.
      #     If the value is greater than 1,000, as a result of excessive paging, there may be a memory leak.
      # - _id: M
      #   _group: "Memory"
      #   _resource: "Memory"
      #   name: Pool non-paged
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2,SELECT PoolNonpagedBytes FROM Win32_PerfFormattedData_PerfOS_Memory]
      #   value_type: UNSIGNED
      #   delay: 1m
      #   units: B
      #   description: |
      #     This measures the size, in bytes, of the non-paged pool. This is an area of system memory for objects
      #     that cannot be written to disk but instead must remain in physical memory as long as they are allocated.
      #     There is a possible memory leak if the value is greater than 175MB (or 100MB with the /3GB switch).
      #     A typical Event ID 2019 is recorded in the system event log.
      # - _id: M
      #   _group: "Memory"
      #   _resource: "Memory"
      #   name: Pool paged
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2,SELECT PoolPagedBytes FROM Win32_PerfFormattedData_PerfOS_Memory]
      #   value_type: UNSIGNED
      #   delay: 1m
      #   units: B
      #   description: |
      #     This measures the size, in bytes, of the paged pool. This is an area of system memory used for objects
      #     that can be written to disk when they are not being used. There may be a memory leak if this value is
      #     greater than 250MB (or 170MB with the /3GB switch). A typical Event ID 2020 is recorded in the system event log.
      # - _id: M
      #   _group: "Memory"
      #   _resource: "Memory"
      #   name: Total
      #   type: ZABBIX_PASSIVE
      #   key: wmi.get[root\cimv2,select TotalPhysicalMemory from Win32_ComputerSystem]
      #   value_type: UNSIGNED
      #   delay: 1m
      #   units: B
      # Performance counters
      # - _id: p
      #   _group: "Memory"
      #   _resource: "Memory"
      #   name: Available
      #   type: ZABBIX_PASSIVE
      #   key: perf_counter_en["\Memory\Available Bytes"]
      #   value_type: UNSIGNED
      #   delay: 1m
      #   units: B
      #   description: |
      #     Performance counter measures the amount of physical memory (RAM), in megabytes, that is immediately
      #     available for allocation either to a process or for system use. It is the sum of the Zero, Free,
      #     and Standby page lists discussed earlier. When the Available MBytes counter is low, it is a primary
      #     indicator of a low RAM condition. This is when aggressive working set trims will occur which may or
      #     may not result in a hard page fault where the pages on the Modified list are written to disk.
      #     The \Memory\Pages/sec counter measures hard page faults, but it does not distinguish between hard
      #     page faults that result from normal file reads or writes and page file reads or writes. Therefore,
      #     use Pages/sec together with the Available MBytes counter, and do not use Pages/sec by itself.
      - _id: item.cache_bytes
        _group: "Memory"
        # _resource: "Memory"
        name: Cache bytes
        type: ZABBIX_PASSIVE
        key: perf_counter_en["\Memory\Cache Bytes"]
        value_type: UNSIGNED
        delay: 1m
        units: B
        description: |
          Cache Bytes is the sum of the Memory\\System Cache Resident Bytes, Memory\\System Driver Resident Bytes, 
          Memory\\System Code Resident Bytes, and Memory\\Pool Paged Resident Bytes counters. This counter displays 
          the last observed value only; it is not an average.
        graphs:
          - name: "Memory statistics"
            graphtype: NORMAL
            graph_items:
              - name: item.cache_bytes
              - name: item.percent_committed
                yaxisside: RIGHT
              - name: item.pagesec
              - name: item.pool_nonpaged
      # - _id: p
      #   _group: "Memory"
      #   _resource: "Memory"
      #   name: Commit limit
      #   type: ZABBIX_PASSIVE
      #   key: perf_counter_en["\Memory\Commit Limit"]
      #   value_type: UNSIGNED
      #   delay: 1m
      #   units: B
      #   description: |
      #     Commit Limit is the amount of virtual memory that can be committed without having to extend
      #     the paging file(s). It is measured in bytes. Committed memory is the physical memory which
      #     has space reserved on the disk paging files. There can be one paging file on each logical drive).
      #     If the paging file(s) are be expanded, this limit increases accordingly. This counter displays
      #     the last observed value only; it is not an average.
      # - _id: p
      #   _group: "Memory"
      #   _resource: "Memory"
      #   name: Committed
      #   type: ZABBIX_PASSIVE
      #   key: perf_counter_en["\Memory\Committed Bytes"]
      #   value_type: UNSIGNED
      #   delay: 1m
      #   units: B
      #   description: |
      #     The system commit charge is the total amount of committed memory that is in use by all processes
      #     and by the kernel. This memory might have been guaranteed or written to by a process or by the kernel.
      #     Memory Available Megabytes in Use This measures the ratio of Committed Bytes to the Commit Limit—in other
      #     words, the amount of virtual memory in use. This indicates insufficient memory if the number is greater
      #     than 80 percent. The obvious solution for this is to add more memory.
      - _id: item.percent_committed
        _group: "Memory"
        # _resource: "Memory"
        name: Committed in use, %
        type: ZABBIX_PASSIVE
        key: perf_counter_en["\Memory\% Committed Bytes In Use"]
        value_type: FLOAT
        delay: 1m
        units: "%"
        description: |
          The \Memory\% Committed Bytes In Use counter calculates the ratio of committed bytes (system commit charge) 
          to the system commit limit, and the system can perform poorly when the system commit limit is reached. 
          Therefore, when % Committed Bytes In Use is greater than 80%, use the \Process(*)\Private Bytes counter 
          to identify the processes that are consuming the most committed memory.
        triggers:
          - _id: trigger.mem.committed.high
            name: "Memory Committed Bytes is too high (over {$MEM.COMMITED.CRIT.MAX}% for 5m)"
            priority: "HIGH"
            expression: "{TEMPLATE_NAME:METRIC.min(5m)}>{$MEM.COMMITED.CRIT.MAX}"
            description: "The Memory\\% Committed Bytes in the last 5 minutes exceeds {$MEM.COMMITED.CRIT.MAX}%. If you see this counter remaining over 80% for an extended time, you have a memory leak, or you need to upgrade your RAM."
      - _id: p
        _group: "Memory"
        # _resource: "Memory"
        name: Free system page table entries
        type: ZABBIX_PASSIVE
        key: perf_counter_en["\Memory\Free System Page Table Entries"]
        value_type: UNSIGNED
        delay: 1m
        units: "entries"
        description: |
          This indicates the number of page table entries not currently in use by the system. If the number is less 
          than 5,000, there may well be a memory leak.
        triggers:
          - _id: trigger.mem.page_table.low
            name: "Free System Page Table Entries is too low (less {$MEM.PAGE_TABLE.CRIT.MAX} for 5m)"
            priority: "HIGH"
            expression: "{TEMPLATE_NAME:METRIC.max(5m)}<{$MEM.PAGE_TABLE.CRIT.MAX}"
            description: "The Memory Free System Page Table Entries is less than {$MEM.PAGE_TABLE.CRIT.MAX} for 5 minutes. If the number is less than 5,000, there may well be a memory leak."
      - _id: p
        _group: "Memory"
        # _resource: "Memory"
        name: Page file usage, %
        type: ZABBIX_PASSIVE
        key: perf_counter_en["\Paging File(_total)\% Usage Peak"]
        value_type: FLOAT
        delay: 1m
        units: "%"
        description: |
          The peak usage of the Page File instance in percent. 
          The Paging File performance object consists of counters that monitor the paging file(s) on the computer. 
          The paging file is a reserved space on disk that backs up committed physical memory on the computer.
      - _id: p
        _group: "Memory"
        # _resource: "Memory"
        name: Pages faults per/sec
        type: ZABBIX_PASSIVE
        key: perf_counter_en["\Memory\Page Faults/sec"]
        value_type: FLOAT
        delay: 1m
        description: |
          Page Faults/sec is the average number of pages faulted per second. It is measured in number of pages 
          faulted per second because only one page is faulted in each fault operation, hence this is also equal 
          to the number of page fault operations. This counter includes both hard faults (those that require 
          disk access) and soft faults (where the faulted page is found elsewhere in physical memory.) Most 
          processors can handle large numbers of soft faults without significant consequence. However, hard faults, 
          which require disk access, can cause significant delays.
      - _id: item.pagesec
        _group: "Memory"
        # _resource: "Memory"
        name: Pages per/sec
        type: ZABBIX_PASSIVE
        key: perf_counter_en["\Memory\Pages/sec"]
        value_type: FLOAT
        delay: 1m
        description: |
          This measures the rate at which pages are read from or written to disk to resolve hard page faults. 
          If the value is greater than 1,000, as a result of excessive paging, there may be a memory leak.
        triggers:
          - _id: trigger.mem.page_sec.low
            name: "The Memory Pages/sec is too high (over {$MEM.PAGE_SEC.CRIT.MAX} for 5m)"
            priority: "HIGH"
            expression: "{TEMPLATE_NAME:METRIC.min(5m)}>{$MEM.PAGE_SEC.CRIT.MAX}"
            description: "The Memory Pages/sec in the last 5 minutes exceeds {$MEM.PAGE_SEC.CRIT.MAX}. If the value is greater than 1,000, as a result of excessive paging, there may be a memory leak."
      - _id: item.pool_nonpaged
        _group: "Memory"
        # _resource: "Memory"
        name: Pool non-paged
        type: ZABBIX_PASSIVE
        key: perf_counter_en["\Memory\Pool Nonpaged Bytes"]
        value_type: UNSIGNED
        delay: 1m
        units: B
        description: |
          This measures the size, in bytes, of the non-paged pool. This is an area of system memory for objects 
          that cannot be written to disk but instead must remain in physical memory as long as they are allocated. 
          There is a possible memory leak if the value is greater than 175MB (or 100MB with the /3GB switch). 
          A typical Event ID 2019 is recorded in the system event log.
      # - _id: p
      #   _group: "Memory"
      #   _resource: "Memory"
      #   name: Pool paged
      #   type: ZABBIX_PASSIVE
      #   key: perf_counter_en["\Memory\Pool Paged Bytes"]
      #   value_type: UNSIGNED
      #   delay: 1m
      #   units: B
      #   description: |
      #     This measures the size, in bytes, of the paged pool. This is an area of system memory used for objects
      #     that can be written to disk when they are not being used. There may be a memory leak if this value is
      #     greater than 250MB (or 170MB with the /3GB switch). A typical Event ID 2020 is recorded in the system event log.
      # - _id: vm.memory.size[free]
      #   _group: "Memory"
      #   name: Free memory
      #   type: ZABBIX_PASSIVE
      #   key: vm.memory.size[free]
      #   value_type: UNSIGNED
      #   delay: 1m
      #   units: B
      # - _id: system.swap.size[,free]
      #   _group: "Memory"
      #   name: Free swap space
      #   type: ZABBIX_PASSIVE
      #   key: system.swap.size[,free]
      #   value_type: UNSIGNED
      #   delay: 1m
      #   units: B
      # - _id: vm.vmemory.size[pavailable]
      #   _group: "Memory"
      #   name: Free virtual memory, in %
      #   type: ZABBIX_PASSIVE
      #   key: vm.vmemory.size[pavailable]
      #   value_type: FLOAT
      #   delay: 1m
      #   units: "%"
      # - _id: vm.memory.size[total]
      #   _group: "Memory"
      #   name: Total memory
      #   type: ZABBIX_PASSIVE
      #   key: vm.memory.size[total]
      #   value_type: UNSIGNED
      #   delay: 1h
      #   units: B
      # - _id: system.swap.size[,total]
      #   _group: "Memory"
      #   name: Total swap space
      #   type: ZABBIX_PASSIVE
      #   key: system.swap.size[,total]
      #   value_type: UNSIGNED
      #   delay: 1h
      #   units: B

  - name: Template OS Windows network by Zabbix agent
    _zbx_ver: "3.4"
    _classes:
      - OS
    macros:
      - macro: "{$NET.IFNAME.MATCHES}"
        value: ".*"
        _description: "This macro is used in Network interface discovery. Can be overriden on the host or linked template level."
      - macro: "{$NET.IFNAME.NOT_MATCHES}"
        value: "Miniport|Virtual|Teredo|Kernel|Loopback|Bluetooth|HTTPS|6to4|QoS|Layer"
        _description: "This macro is used in Network interface discovery. Can be overriden on the host or linked template level."
    discovery_rules:
      - name: Network interface discovery
        key: net.if.discovery
        type: ZABBIX_PASSIVE
        description: Discovery of network interfaces as defined in {$NET.IFNAME.MATCHES} and {$NET.IFNAME.NOT_MATCHES}.
        filter:
          evalType: "AND"
          conditions:
            - macro: "{#IFNAME}"
              value: "{$NET.IFNAME.MATCHES}"
              operator: "MATCHES_REGEX"
              formulaid: "A"
            - macro: "{#IFNAME}"
              value: "{$NET.IFNAME.NOT_MATCHES}"
              operator: "NOT_MATCHES_REGEX"
              formulaid: "B"
        items:
          # - _prototype: "net.if.in"
          #   type: "ZABBIX_PASSIVE"
          #   _resource: "Interface {#IFNAME}"
          #   key: 'net.if.in["{#IFNAME}"]'
          #   # removing trigger if.util_high since there is no net.if.speed to evaluate it properly.
          #   # triggers": [],
          # - _prototype: "net.if.out"
          #   type: "ZABBIX_PASSIVE"
          #   _resource: "Interface {#IFNAME}"
          #   key: 'net.if.out["{#IFNAME}"]'
          - _id: "net.if.in"
            type: "ZABBIX_PASSIVE"
            _resource: "Interface {#IFNAME}"
            key: 'net.if.in["{#IFNAME}"]'
            name: "Bits received"
            _group: "Network_interfaces"
            # application_prototype: "__RESOURCE__"
            value_type: "UNSIGNED"
            delay: "1m"
            history: "7d"
            units: "bps"
          - _id: "net.if.out"
            type: "ZABBIX_PASSIVE"
            _resource: "Interface {#IFNAME}"
            key: 'net.if.out["{#IFNAME}"]'
            name: "Bits sent"
            _group: "Network_interfaces"
            # application_prototype: "__RESOURCE__"
            delay: "1m"
            history: "7d"
            value_type: "UNSIGNED"
            units: "bps"
            graphs:
              - name: "Network traffic"
                graph_items:
                  - name: "net.if.in"
                    drawtype: "GRADIENT_LINE"
                    yaxisside: "LEFT"
                  - name: "net.if.out"
                    drawtype: "BOLD_LINE"
                    yaxisside: "LEFT"
          # - _id: wmi.get[root\cimv2,select BytesReceivedPersec from Win32_PerfFormattedData_Tcpip_NetworkInterface where Name='{#IFNAME}']
          #   _group: "Network_interfaces"
          #   _resource: Interface
          #   name: "{#IFNAME}: Incoming network traffic"
          #   key: wmi.get[root\cimv2,select BytesReceivedPersec from Win32_PerfFormattedData_Tcpip_NetworkInterface where Name='{#IFNAME}']
          #   type: ZABBIX_PASSIVE
          #   value_type: UNSIGNED
          #   units: Bps
          #   description: .
          # - _id: wmi.get[root\cimv2,select BytesSentPersec from Win32_PerfFormattedData_Tcpip_NetworkInterface where Name='{#IFNAME}']
          #   _group: "Network_interfaces"
          #   _resource: Interface
          #   name: "{#IFNAME}: Outgoing network traffic"
          #   key: wmi.get[root\cimv2,select BytesSentPersec from Win32_PerfFormattedData_Tcpip_NetworkInterface where Name='{#IFNAME}']
          #   type: ZABBIX_PASSIVE
          #   value_type: UNSIGNED
          #   units: Bps
          #   description: .
          # - _id: wmi.get[root\cimv2,select NetConnectionStatus from win32_networkadapter where Name='{#IFNAME}']
          #   _group: "Network_interfaces"
          #   _resource: Interface
          #   name: "{#IFNAME}: Network carrier"
          #   key: wmi.get[root\cimv2,select NetConnectionStatus from win32_networkadapter where Name='{#IFNAME}']
          #   type: ZABBIX_PASSIVE
          #   value_type: UNSIGNED
          #   description: .
          # - _id: wmi.get[root\cimv2,select OutputQueueLength from Win32_PerfFormattedData_Tcpip_NetworkInterface where Name='{#IFNAME}']
          #   _group: "Network_interfaces"
          #   _resource: Interface
          #   name: "{#IFNAME}: Output queue length"
          #   key: wmi.get[root\cimv2,select OutputQueueLength from Win32_PerfFormattedData_Tcpip_NetworkInterface where Name='{#IFNAME}']
          #   type: ZABBIX_PASSIVE
          #   value_type: UNSIGNED
          #   description: .
          # - _id: wmi.get[root\cimv2,select BytesTotalPersec from Win32_PerfFormattedData_Tcpip_NetworkInterface where Name='{#IFNAME}']
          #   _group: "Network_interfaces"
          #   _resource: Interface
          #   name: "{#IFNAME}: Total network traffic"
          #   key: wmi.get[root\cimv2,select BytesTotalPersec from Win32_PerfFormattedData_Tcpip_NetworkInterface where Name='{#IFNAME}']
          #   type: ZABBIX_PASSIVE
          #   value_type: UNSIGNED
          #   units: Bps
          #   description: .

  - name: Template OS Windows by Zabbix agent
    _zbx_ver: "3.4"
    _classes:
      - OS
    description: |
      Official Linux template. Requires agent of Zabbix 3.0.14, 3.4.5 and 4.0.0 or newer.
    _documentation:
      _zabbix_forum_url: https://www.zabbix.com/forum/zabbix-suggestions-and-feedback/384765-discussion-thread-for-official-zabbix-template-nginx
      _tested_on:
        - name: Windows
          version: "10"
      _overview: |
        New official Windows template. Requires agent of Zabbix 3.0.14, 3.4.5 and 4.0.0 or newer.
      _setup: |
        Install Zabbix agent to Windows OS according to Zabbix documentation.
    templates:
      - Template OS Windows CPU by Zabbix agent
      - Template OS Windows filesystems by Zabbix agent
      - Template OS Windows inventory by Zabbix agent
      - Template OS Windows memory by Zabbix agent
      - Template OS Windows network by Zabbix agent
      # - Template OS Windows disk performance by Zabbix agent
    # screens:
    #   - name: "System performance"
    #     hsize: 2
    #     vsize: 2
    #     screen_items:
    #       - _graph_id: memory.usage
    #         x: 0
    #         y: 0
    #       - _graph_id: cpu.usage
    #         x: 1
    #         y: 0
    #       - _graph_id:
    #         x: 0
    #         y: 1
